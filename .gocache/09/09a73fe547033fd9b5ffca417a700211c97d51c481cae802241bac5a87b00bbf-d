// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/hujiayilu/go/pkg/mod/github.com/shirou/gopsutil/v3@v3.23.10/process/process_darwin_cgo.go:1:1
//go:build darwin && cgo
// +build darwin,cgo

package process; import _cgo_unsafe "unsafe"

// #include <stdlib.h>
// #include <libproc.h>
// #include <string.h>
// #include <sys/errno.h>
// #include <sys/proc_info.h>
// #include <sys/sysctl.h>
// #include <mach/mach_time.h>
import _ "unsafe"

import (
	"bytes"
	"context"
	"fmt"
	"strings"
	"syscall"
	"unsafe"

	"github.com/shirou/gopsutil/v3/cpu"
)

var (
	argMax                 int
	timescaleToNanoSeconds float64
)

func init() {
	argMax = getArgMax()
	timescaleToNanoSeconds = getTimeScaleToNanoSeconds()
}

func getArgMax() int {
	var (
		mib    = [...] /*line :38:17*/_Ctype_int /*line :38:22*/{( /*line :38:23*/_Ciconst_CTL_KERN /*line :38:32*/), ( /*line :38:35*/_Ciconst_KERN_ARGMAX /*line :38:47*/)}
		argmax  /*line :39:10*/_Ctype_int /*line :39:15*/
		size    /*line :40:10*/_Ctype_size_t /*line :40:18*/ =  /*line :40:21*/_Ctype_ulong /*line :40:28*/(unsafe.Sizeof(argmax))
	)
	retval := func() _Ctype_int{ var _cgo0 *_Ctype_int = /*line :42:21*/&mib[0]; var _cgo1 _Ctype_u_int = /*line :42:30*/2; _cgoBase2 := /*line :42:48*/&argmax; _cgo2 := /*line :42:33*/unsafe.Pointer(_cgoBase2); var _cgo3 *_Ctype_size_t = /*line :42:58*/&size; _cgo4 := /*line :42:65*/_Cmacro_NULL /*line :42:71*/(); var _cgo5 _Ctype_size_t = /*line :42:73*/0; _cgoCheckPointer(_cgoBase2, 0 == 0); _cgoCheckPointer(_cgo4, nil); return /*line :42:75*/_Cfunc_sysctl(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if retval == 0 {
		return int(argmax)
	}
	return 0
}

func getTimeScaleToNanoSeconds() float64 {
	var timeBaseInfo  /*line :50:19*/_Ctype_struct_mach_timebase_info /*line :50:46*/

	( /*line :52:2*/_Cfunc_mach_timebase_info /*line :52:21*/)(&timeBaseInfo)

	return float64(timeBaseInfo.numer) / float64(timeBaseInfo.denom)
}

func (p *Process) ExeWithContext(ctx context.Context) (string, error) {
	var c  /*line :58:8*/_Ctype_char /*line :58:14*/ // need a var for unsafe.Sizeof need a var
	const bufsize = ( /*line :59:18*/_Ciconst_PROC_PIDPATHINFO_MAXSIZE /*line :59:43*/) * unsafe.Sizeof(c)
	buffer := (* /*line :60:14*/_Ctype_char /*line :60:20*/)(( /*line :60:22*/_Cfunc__CMalloc /*line :60:29*/)( /*line :60:31*/_Ctype_size_t /*line :60:39*/(bufsize)))
	defer func() func() { _cgo0 := /*line :61:15*/unsafe.Pointer(buffer); return func() { _cgoCheckPointer(_cgo0, nil); /*line :61:38*/_Cfunc_free(_cgo0); }}()()

	ret, err := func() (_Ctype_int, error){ var _cgo0 _Ctype_int = _Ctype_int /*line :63:34*/(p.Pid); _cgo1 := /*line :63:43*/unsafe.Pointer(buffer); var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :63:77*/(bufsize); _cgoCheckPointer(_cgo1, nil); return /*line :63:87*/_C2func_proc_pidpath(_cgo0, _cgo1, _cgo2); }()
	if err != nil {
		return "", err
	}
	if ret <= 0 {
		return "", fmt.Errorf("unknown error: proc_pidpath returned %d", ret)
	}

	return ( /*line :71:9*/_Cfunc_GoString /*line :71:18*/)(buffer), nil
}

// CwdWithContext retrieves the Current Working Directory for the given process.
// It uses the proc_pidinfo from libproc and will only work for processes the
// EUID can access.  Otherwise "operation not permitted" will be returned as the
// error.
// Note: This might also work for other *BSD OSs.
func (p *Process) CwdWithContext(ctx context.Context) (string, error) {
	const vpiSize = ( /*line :80:18*/_Ciconst_sizeof_struct_proc_vnodepathinfo /*line :80:51*/)
	vpi := (* /*line :81:11*/_Ctype_struct_proc_vnodepathinfo /*line :81:38*/)(( /*line :81:40*/_Cfunc__CMalloc /*line :81:47*/)(vpiSize))
	defer func() func() { _cgo0 := /*line :82:15*/unsafe.Pointer(vpi); return func() { _cgoCheckPointer(_cgo0, nil); /*line :82:35*/_Cfunc_free(_cgo0); }}()()
	ret, err := func() (_Ctype_int, error){ var _cgo0 _Ctype_int = _Ctype_int /*line :83:34*/(p.Pid); var _cgo1 _Ctype_int = /*line :83:43*/_Ciconst_PROC_PIDVNODEPATHINFO /*line :83:66*/; var _cgo2 _Ctype_uint64_t = /*line :83:68*/0; _cgo3 := /*line :83:71*/unsafe.Pointer(vpi); var _cgo4 _Ctype_int = /*line :83:92*/vpiSize; _cgoCheckPointer(_cgo3, nil); return /*line :83:100*/_C2func_proc_pidinfo(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	if err != nil {
		// fmt.Printf("ret: %d %T\n", ret, err)
		if err == syscall.EPERM {
			return "", ErrorNotPermitted
		}
		return "", err
	}
	if ret <= 0 {
		return "", fmt.Errorf("unknown error: proc_pidinfo returned %d", ret)
	}
	if ret != ( /*line :94:12*/_Ciconst_sizeof_struct_proc_vnodepathinfo /*line :94:45*/) {
		return "", fmt.Errorf("too few bytes; expected %d, got %d", vpiSize, ret)
	}
	return ( /*line :97:9*/_Cfunc_GoString /*line :97:18*/)(&vpi.pvi_cdir.vip_path[0]), err
}

func procArgs(pid int32) ([]byte, int, error) {
	var (
		mib             = [...] /*line :102:26*/_Ctype_int /*line :102:31*/{( /*line :102:32*/_Ciconst_CTL_KERN /*line :102:41*/), ( /*line :102:44*/_Ciconst_KERN_PROCARGS2 /*line :102:59*/),  /*line :102:62*/_Ctype_int /*line :102:67*/(pid)}
		size    /*line :103:10*/_Ctype_size_t /*line :103:18*/ =  /*line :103:21*/_Ctype_ulong /*line :103:28*/(argMax)
		nargs   /*line :104:10*/_Ctype_int /*line :104:15*/
		result []byte
	)
	procargs := (* /*line :107:16*/_Ctype_char /*line :107:22*/)(( /*line :107:24*/_Cfunc__CMalloc /*line :107:31*/)( /*line :107:33*/_Ctype_ulong /*line :107:40*/(argMax)))
	defer func() func() { _cgo0 := /*line :108:15*/unsafe.Pointer(procargs); return func() { _cgoCheckPointer(_cgo0, nil); /*line :108:40*/_Cfunc_free(_cgo0); }}()()
	retval, err := func() (_Ctype_int, error){ var _cgo0 *_Ctype_int = /*line :109:26*/&mib[0]; var _cgo1 _Ctype_u_int = /*line :109:35*/3; _cgo2 := /*line :109:38*/unsafe.Pointer(procargs); var _cgo3 *_Ctype_size_t = /*line :109:64*/&size; _cgo4 := /*line :109:71*/_Cmacro_NULL /*line :109:77*/(); var _cgo5 _Ctype_size_t = /*line :109:79*/0; _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo4, nil); return /*line :109:81*/_C2func_sysctl(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if retval == 0 {
		func() _cgo_unsafe.Pointer{ _cgoBase0 := /*line :111:27*/&nargs; _cgo0 := /*line :111:12*/unsafe.Pointer(_cgoBase0); _cgo1 := /*line :111:36*/unsafe.Pointer(procargs); var _cgo2 _Ctype_size_t = /*line :111:62*/_Ciconst_sizeof_int /*line :111:74*/; _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgo1, nil); return /*line :111:75*/_Cfunc_memcpy(_cgo0, _cgo1, _cgo2); }()
		result = func() []byte{ _cgo0 := /*line :112:22*/unsafe.Pointer(procargs); var _cgo1 _Ctype_int = _Ctype_int /*line :112:53*/(size); _cgoCheckPointer(_cgo0, nil); return /*line :112:60*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
		// fmt.Printf("size: %d %d\n%s\n", size, nargs, hex.Dump(result))
		return result, int(nargs), nil
	}
	return nil, 0, err
}

func (p *Process) CmdlineSliceWithContext(ctx context.Context) ([]string, error) {
	return p.cmdlineSliceWithContext(ctx, true)
}

func (p *Process) cmdlineSliceWithContext(ctx context.Context, fallback bool) ([]string, error) {
	pargs, nargs, err := procArgs(p.Pid)
	if err != nil {
		return nil, err
	}
	// The first bytes hold the nargs int, skip it.
	args := bytes.Split((pargs)[( /*line :129:30*/_Ciconst_sizeof_int /*line :129:41*/):], []byte{0})
	var argStr string
	// The first element is the actual binary/command path.
	// command := args[0]
	var argSlice []string
	// var envSlice []string
	// All other, non-zero elements are arguments. The first "nargs" elements
	// are the arguments. Everything else in the slice is then the environment
	// of the process.
	for _, arg := range args[1:] {
		argStr = string(arg[:])
		if len(argStr) > 0 {
			if nargs > 0 {
				argSlice = append(argSlice, argStr)
				nargs--
				continue
			}
			break
			// envSlice = append(envSlice, argStr)
		}
	}
	return argSlice, err
}

// cmdNameWithContext returns the command name (including spaces) without any arguments
func (p *Process) cmdNameWithContext(ctx context.Context) (string, error) {
	r, err := p.cmdlineSliceWithContext(ctx, false)
	if err != nil {
		return "", err
	}

	if len(r) == 0 {
		return "", nil
	}

	return r[0], err
}

func (p *Process) CmdlineWithContext(ctx context.Context) (string, error) {
	r, err := p.CmdlineSliceWithContext(ctx)
	if err != nil {
		return "", err
	}
	return strings.Join(r, " "), err
}

func (p *Process) NumThreadsWithContext(ctx context.Context) (int32, error) {
	const tiSize = ( /*line :176:17*/_Ciconst_sizeof_struct_proc_taskinfo /*line :176:45*/)
	ti := (* /*line :177:10*/_Ctype_struct_proc_taskinfo /*line :177:32*/)(( /*line :177:34*/_Cfunc__CMalloc /*line :177:41*/)(tiSize))
	defer func() func() { _cgo0 := /*line :178:15*/unsafe.Pointer(ti); return func() { _cgoCheckPointer(_cgo0, nil); /*line :178:34*/_Cfunc_free(_cgo0); }}()()

	_, err := func() (_Ctype_int, error){ var _cgo0 _Ctype_int = _Ctype_int /*line :180:32*/(p.Pid); var _cgo1 _Ctype_int = /*line :180:41*/_Ciconst_PROC_PIDTASKINFO /*line :180:59*/; var _cgo2 _Ctype_uint64_t = /*line :180:61*/0; _cgo3 := /*line :180:64*/unsafe.Pointer(ti); var _cgo4 _Ctype_int = /*line :180:84*/tiSize; _cgoCheckPointer(_cgo3, nil); return /*line :180:91*/_C2func_proc_pidinfo(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	if err != nil {
		return 0, err
	}

	return int32(ti.pti_threadnum), nil
}

func (p *Process) TimesWithContext(ctx context.Context) (*cpu.TimesStat, error) {
	const tiSize = ( /*line :189:17*/_Ciconst_sizeof_struct_proc_taskinfo /*line :189:45*/)
	ti := (* /*line :190:10*/_Ctype_struct_proc_taskinfo /*line :190:32*/)(( /*line :190:34*/_Cfunc__CMalloc /*line :190:41*/)(tiSize))
	defer func() func() { _cgo0 := /*line :191:15*/unsafe.Pointer(ti); return func() { _cgoCheckPointer(_cgo0, nil); /*line :191:34*/_Cfunc_free(_cgo0); }}()()

	_, err := func() (_Ctype_int, error){ var _cgo0 _Ctype_int = _Ctype_int /*line :193:32*/(p.Pid); var _cgo1 _Ctype_int = /*line :193:41*/_Ciconst_PROC_PIDTASKINFO /*line :193:59*/; var _cgo2 _Ctype_uint64_t = /*line :193:61*/0; _cgo3 := /*line :193:64*/unsafe.Pointer(ti); var _cgo4 _Ctype_int = /*line :193:84*/tiSize; _cgoCheckPointer(_cgo3, nil); return /*line :193:91*/_C2func_proc_pidinfo(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	if err != nil {
		return nil, err
	}

	ret := &cpu.TimesStat{
		CPU:    "cpu",
		User:   float64(ti.pti_total_user) * timescaleToNanoSeconds / 1e9,
		System: float64(ti.pti_total_system) * timescaleToNanoSeconds / 1e9,
	}
	return ret, nil
}

func (p *Process) MemoryInfoWithContext(ctx context.Context) (*MemoryInfoStat, error) {
	const tiSize = ( /*line :207:17*/_Ciconst_sizeof_struct_proc_taskinfo /*line :207:45*/)
	ti := (* /*line :208:10*/_Ctype_struct_proc_taskinfo /*line :208:32*/)(( /*line :208:34*/_Cfunc__CMalloc /*line :208:41*/)(tiSize))
	defer func() func() { _cgo0 := /*line :209:15*/unsafe.Pointer(ti); return func() { _cgoCheckPointer(_cgo0, nil); /*line :209:34*/_Cfunc_free(_cgo0); }}()()

	_, err := func() (_Ctype_int, error){ var _cgo0 _Ctype_int = _Ctype_int /*line :211:32*/(p.Pid); var _cgo1 _Ctype_int = /*line :211:41*/_Ciconst_PROC_PIDTASKINFO /*line :211:59*/; var _cgo2 _Ctype_uint64_t = /*line :211:61*/0; _cgo3 := /*line :211:64*/unsafe.Pointer(ti); var _cgo4 _Ctype_int = /*line :211:84*/tiSize; _cgoCheckPointer(_cgo3, nil); return /*line :211:91*/_C2func_proc_pidinfo(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	if err != nil {
		return nil, err
	}

	ret := &MemoryInfoStat{
		RSS:  uint64(ti.pti_resident_size),
		VMS:  uint64(ti.pti_virtual_size),
		Swap: uint64(ti.pti_pageins),
	}
	return ret, nil
}
